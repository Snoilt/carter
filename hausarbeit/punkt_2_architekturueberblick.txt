2 Architekturüberblick

Die Architektur von „kardr“ ist bewusst schlank gehalten und auf die zuverlässige, nachvollziehbare Berechnung von Wiederholungsintervallen nach FSRS ausgelegt. Das System besteht aus einem Nuxt‑basierten Frontend für die Interaktion mit den Lernkarten, einem PocketBase‑Backend als leichtgewichtiger Authentifizierungs‑ und Datenspeicherkomponente sowie einem ergänzenden Go‑Dienst, der dort, wo nötig, kundenspezifische Routen bereitstellt und die serverseitige Berechnung der Fälligkeiten koordiniert. Diese Aufteilung stellt sicher, dass die FSRS‑Logik deterministisch und zentral ausgeführt wird, während das Frontend eine reaktive und performante Nutzererfahrung liefert. Die gesamte Umsetzung folgt einem API‑first‑Ansatz: Das Frontend spricht wohldefinierte HTTP‑Endpunkte an, die Zustandsänderungen (z. B. Reviews) validieren und transaktional persistieren.

2.1 Tech‑Stack (Nuxt 4, PocketBase, Go, Bun)

Das Frontend setzt auf Nuxt 4 und damit auf Vue 3, Composition API und dateibasiertes Routing. Diese Wahl ermöglicht eine klare Trennung von Seiten, Komponenten und Composables sowie kurze Entwicklungszyklen. Durch Nuxt lassen sich SSR/CSR‑Strategien flexibel kombinieren; für „kardr“ steht jedoch der reaktive Client‑Flow im Vordergrund, der Review‑Ereignisse unmittelbar an die API sendet und Ergebnisse (nächstes Fälligkeitsdatum, aktualisierte Stabilität) zurückerhält. PocketBase übernimmt Authentifizierung, Rechteprüfung und Speicherung der zentralen Domänenobjekte (Karten, Reviews, nutzerspezifische Parameter). Es bietet eine kompakte Laufzeit, integrierte Migrationsmechanismen und ein einfaches Betriebsmodell, was für den MVP‑Charakter von „kardr“ entscheidend ist. Der Go‑Dienst erweitert PocketBase um projektspezifische Routen, kapselt die FSRS‑Berechnungen serverseitig und stellt sicher, dass Berechnungsregeln und Versionierung an einem Ort konsistent bleiben. Für das lokale Development kommt Bun zum Einsatz, um Installation und Scripts (Dev‑Server, Build, Linting) schnell auszuführen und eine homogene Entwicklererfahrung zu gewährleisten.

2.2 Repo‑Struktur und Build/Laufkommandos

Die Repository‑Struktur spiegelt die Architekturelemente wider. Unter „app/“ liegt der Nuxt‑Client mit Seiten, Komponenten, Composables, Middleware und Assets. Der Ordner „database/“ enthält den Go‑Dienst, der PocketBase um kundenspezifische Routen ergänzt. Im Verzeichnis „pocketbase/“ befindet sich die PocketBase‑Binary sowie „pb_hooks/“ und „pb_migrations/“, über die serverseitige Logik und Schemaänderungen verwaltet werden. Statische Dateien liegen in „public/“, während projektspezifische Konfigurationen (etwa „nuxt.config.ts“, „eslint.config.mjs“, „tsconfig.json“) im Repo‑Wurzelverzeichnis gepflegt werden. Für die lokale Entwicklung werden die Abhängigkeiten vorzugsweise mit Bun installiert; der Nuxt‑Entwicklungsserver wird über das bereitgestellte Script gestartet. Der Build erzeugt ein produktionsfähiges Artefakt, das sich im Preview prüfen lässt. PocketBase wird separat gestartet, wodurch Migrationen angewendet und Hooks geladen werden; zusätzlich steht ein Type‑Generator bereit, der die PocketBase‑Typen für den Frontend‑Code ableitet. Zusammengenommen erlauben diese Kommandos einen reproduzierbaren Zyklus aus Installieren, Entwickeln, Bauen und lokalen Prüfungen, wobei die Umbenennung des Projekts auf „kardr“ in Konfigurationen und Pfaden konsistent nachvollzogen wird.

