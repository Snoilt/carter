5 Backend‑Integration

Die Backend‑Integration von „kardr“ bündelt Authentifizierung, Persistenz und die serverseitige FSRS‑Berechnung hinter klaren HTTP‑Schnittstellen. Ziel ist, dass alle zustandsändernden Operationen – insbesondere das Verbuchen eines Reviews – deterministisch und nachvollziehbar auf dem Server ausgeführt werden. Dadurch bleiben Berechnungsregeln, Gewichte und Zeitbezug konsistent, Manipulationen auf dem Client werden vermieden und konkurrierende Änderungen lassen sich kontrolliert behandeln. Der Go‑Dienst registriert dazu kundenspezifische Routen an PocketBase, nutzt die bereitgestellte Datenbankschicht transaktional und versieht Antworten mit den aktualisierten FSRS‑Zuständen, damit das Frontend ohne eigene Algorithmik reagieren kann.

5.1 Routen und Endpunkte

Die zentrale Zustandsänderung erfolgt über einen Review‑Endpunkt, der die Bewertung einer Karte samt verstrichener Zeit entgegennimmt und das nächste Fälligkeitsdatum berechnet. Ergänzend stellt das Backend eine Abfrage fälliger Karten bereit, sodass das Frontend den Review‑Stapel nutzerbezogen laden kann. Nutzerinnen und Nutzer können ihre FSRS‑Parameter – insbesondere die gewünschte Behaltensrate und optional eine Deadline – über einen eigenen Einstellungs‑Endpunkt setzen. Für die kompetitive Motivation aggregiert der Server belastbare Kennzahlen aus der Review‑Historie und stellt sie über eine Lese‑Schnittstelle bereit; damit lassen sich Ranglisten oder Vergleiche darstellen, ohne dass der Client Rohdaten interpretieren muss. Die genauen Pfade und Felder sind in der API‑Spezifikation im Anhang beschrieben und werden versioniert vorgehalten, damit sich Änderungen kontrolliert ausrollen lassen.

5.2 Scheduling‑Pipeline und Serverlogik

Nach Eingang eines Review‑Requests validiert der Server zunächst Identität und Zugriffsrechte und lädt den aktuellen Kartenzustand zusammen mit den nutzerspezifischen Parametern. Aus der gespeicherten Stabilität und der seit der letzten Wiederholung verstrichenen Zeit wird die Abrufwahrscheinlichkeit abgeleitet. Auf Basis der Bewertung berechnet der Server die neue Stabilität nach den FSRS‑Regeln und leitet daraus das nächste Intervall ab; falls eine Deadline gesetzt ist, wird das Ergebnis auf das zulässige Zeitfenster gekappt. Anschließend aktualisiert der Server Karte und Review‑Protokoll in einer gemeinsamen Transaktion und antwortet mit dem neuen Kartenzustand inklusive nächster Fälligkeit. Die gesamte Berechnung findet auf dem Server statt, sodass Ergebnisse bei gleicher Eingabe reproduzierbar sind und keine divergierenden Client‑Implementierungen entstehen.

Die Pipeline ist auf Idempotenz und Nebenläufigkeit ausgelegt. Anfragen können eine eindeutige Review‑Kennung mitführen, sodass doppelt gesendete Requests denselben persistierten Vorgang zurückliefern, statt den Zustand erneut zu verändern. Bei zeitnahen Parallel‑Reviews derselben Karte erkennt der Server konkurrierende Updates über Versions‑ oder Zeitstempel und lehnt veraltete Änderungen ab, damit keine unvollständigen Zwischenstände gespeichert werden. Der Zeitbezug wird dabei einheitlich in UTC geführt, um Abweichungen zwischen Client‑Uhrzeiten und Server zu vermeiden.

5.3 Validierung, Fehlerfälle und Rate‑Limiting

Alle Eingaben werden strikt geprüft: Bewertungen sind nur im erlaubten Wertebereich zulässig, Zeitangaben müssen plausibel sein und Karten dürfen ausschließlich von ihren Eigentümerinnen und Eigentümern reviewed werden. Fehler werden mit konsistenten Codes und einer knappen, maschinenlesbaren Beschreibung zurückgegeben, sodass das Frontend klar zwischen Validierungsfehlern, fehlenden Rechten und unerwarteten Zuständen unterscheiden kann. Bei veralteten Client‑Ständen – etwa wenn ein zweites Fenster dieselbe Karte bereits aktualisiert hat – gibt der Server einen Konflikt zurück, den das Frontend durch erneutes Laden der Karte auflösen kann. Um Missbrauch zu verhindern, begrenzt ein einfaches Rate‑Limiting die Frequenz schreibender Anfragen pro Nutzerin bzw. Nutzer und Route, ohne den regulären Review‑Fluss zu stören. Logging und Korrelation von Requests erlauben die Nachverfolgung einzelner Berechnungsschritte während der Entwicklung; produktionsnahe sensibel Daten werden nicht geloggt.

